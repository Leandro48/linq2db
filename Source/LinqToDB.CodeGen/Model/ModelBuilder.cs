using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using LinqToDB.CodeGen.CodeGeneration;
using LinqToDB.CodeGen.ContextModel;
using LinqToDB.CodeGen.DataModel;
using LinqToDB.CodeGen.Metadata;
using LinqToDB.CodeGen.Naming;
using LinqToDB.CodeGen.Schema;

namespace LinqToDB.CodeGen.Model
{

	public class ModelBuilder
	{
		private readonly ISchemaProvider _schemaProvider;
		private readonly ITypeMappingProvider _typeMappingsProvider;

		private readonly ILanguageProvider _languageProvider;

		private readonly SchemaSettings _schemaSettings;
		private readonly CodeGenerationSettings _codegenSettings;
		private readonly ContextModelSettings _contextSettings;
		private readonly NamingServices _namingServices;

		private readonly Dictionary<ObjectName, (TableLikeObject schemaObject, EntityModel entity)> _entities = new ();
		private readonly Dictionary<(EntityModel, string), ColumnModel> _columns = new ();

		public ModelBuilder(
			ISchemaProvider schemaProvider,
			ITypeMappingProvider typeMappingsProvider,
			ILanguageProvider languageProvider,
			SchemaSettings schemaSettings,
			CodeGenerationSettings codegenSettings,
			ContextModelSettings contextSettings,
			INameConverterProvider pluralizationProvider,
			NamingServices namingServices)
		{
			_schemaProvider = schemaProvider;
			_typeMappingsProvider = typeMappingsProvider;
			_languageProvider = languageProvider;
			_schemaSettings = schemaSettings;
			_codegenSettings = codegenSettings;
			_contextSettings = contextSettings;
			_namingServices = namingServices;
		}

		public DatabaseModel Build()
		{
			var dataContext = BuildDataContext();

			var model = new DatabaseModel(dataContext);

			model.NRTEnabled = _languageProvider.NRTSupported && _codegenSettings.NullableReferenceTypes;
			model.DisableXmlDocWarnings = _languageProvider.MissingXmlCommentWarnCodes.Length > 0 && _codegenSettings.SuppressMissingXmlCommentWarnings;

			var defaultSchemas = _schemaProvider.GetDefaultSchemas();

			if (_codegenSettings.MarkAsAutoGenerated)
			{
				model.AutoGeneratedComment = @"This code was generated by LinqToDB scaffolding tool (https://github.com/linq2db/linq2db).
Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.";
			}

			IType? baseEntityType = null;


			if (_contextSettings.BaseEntityClass != null)
			{
				baseEntityType = _languageProvider.TypeParser.Parse(_contextSettings.BaseEntityClass, false);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.Table))
			{
				foreach (var table in _schemaProvider.GetTables())
					BuildEntity(model, table, table.PrimaryKey, table.Identity, defaultSchemas, baseEntityType);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.View))
			{
				foreach (var view in _schemaProvider.GetViews())
					BuildEntity(model, view, null, view.Identity, defaultSchemas, baseEntityType);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.ForeignKey))
			{
				foreach (var fk in _schemaProvider.GetForeignKeys())
				{
					var association = BuildAssociations(fk, defaultSchemas);
					if (association != null)
						model.Associations.Add(association);
				}
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.StoredProcedure))
			{
				foreach (var proc in _schemaProvider.GetProcedures(_schemaSettings.LoadProceduresSchema, _schemaSettings.UseSafeSchemaLoad))
					BuildStoredProcedure(model, proc, defaultSchemas);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.TableFunction))
			{
				foreach (var func in _schemaProvider.GetTableFunctions(_schemaSettings.LoadTableFunctionsSchema, _schemaSettings.UseSafeSchemaLoad))
					BuildTableFunction(model, func, defaultSchemas);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.ScalarFunction))
			{
				foreach (var func in _schemaProvider.GetScalarFunctions())
					BuildScalarFunction(model, func, defaultSchemas);
			}

			if (_schemaSettings.Objects.HasFlag(SchemaObjects.AggregateFunction))
			{
				foreach (var func in _schemaProvider.GetAggregateFunctions())
					BuildAggregateFunction(model, func, defaultSchemas);
			}

			return model;
		}

		private void BuildAggregateFunction(DatabaseModel model, AggregateFunction func, ISet<string> defaultSchemas)
		{
			var (name, isNonDefaultSchema) = ProcessObjectName(func.Name, defaultSchemas);

			var method = new MethodModel(_namingServices.NormalizeIdentifier(_contextSettings.ProcedureNameNormalization, name.Name))
			{
				Public = true,
				Static = true,
				Summary = func.Description,
				Extension = true
			};

			var metadata = new FunctionMetadata()
			{
				Name = name,
				ServerSideOnly = true,
				IsAggregate = true
			};

			if (func.Parameters.Count > 0)
			{
				metadata.ArgIndices = new int[func.Parameters.Count];
				for (var i = 0; i < metadata.ArgIndices.Length; i++)
					metadata.ArgIndices[i] = i + 1;
			}

			if (func.Result is not ScalarResult scalarResult)
				throw new InvalidOperationException();

			var typeMapping = _typeMappingsProvider.GetTypeMapping(scalarResult.Type);

			var funcModel = new AggregateFunctionModel(name, method, metadata, (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(scalarResult.Nullable));

			BuildParameters(func.Parameters, funcModel.Parameters);

			if (isNonDefaultSchema && _contextSettings.GenerateSchemaAsType)
				GetOrAddSchemaType(model, func.Name.Schema!).AggregateFunctions.Add(funcModel);
			else
				model.DataContext.AggregateFunctions.Add(funcModel);
		}

		private void BuildScalarFunction(DatabaseModel model, ScalarFunction func, ISet<string> defaultSchemas)
		{
			var (name, isNonDefaultSchema) = ProcessObjectName(func.Name, defaultSchemas);

			var method = new MethodModel(_namingServices.NormalizeIdentifier(_contextSettings.ProcedureNameNormalization, name.Name))
			{
				Public = true,
				Static = true,
				Summary = func.Description
			};

			var metadata = new FunctionMetadata()
			{
				Name = name,
				ServerSideOnly = true
			};

			var funcModel = new ScalarFunctionModel(name, method, metadata);

			BuildParameters(func.Parameters, funcModel.Parameters);

			switch (func.Result.Kind)
			{
				case ResultKind.Dynamic:
					throw new NotImplementedException();
				case ResultKind.Scalar:
				{
					var scalarResult = (ScalarResult)func.Result;
					var typeMapping = _typeMappingsProvider.GetTypeMapping(scalarResult.Type);
					//DataType not used by current mappings
					funcModel.Return = (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(scalarResult.Nullable);
					break;
				}
				case ResultKind.Tuple:
				{
					var tupleResult = (TupleResult)func.Result;

					var @class = new ClassModel(_namingServices.NormalizeIdentifier(_contextSettings.FunctionTupleResultClassName, func.Name.Name))
					{
						IsPublic = true,
						IsPartial = true
					};
					funcModel.ReturnTuple = new TupleModel(@class)
					{
						CanBeNull = tupleResult.Nullable
					};

					foreach (var field in tupleResult.Fields)
					{
						var typeMapping = _typeMappingsProvider.GetTypeMapping(field.Type);

						var prop = new PropertyModel(_namingServices.NormalizeIdentifier(_contextSettings.FunctionTupleResultPropertyName, field.Name ?? "Field"), (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(field.Nullable))
						{
							IsPublic = true,
							IsDefault = true,
							HasSetter = true
						};
						funcModel.ReturnTuple.Fields.Add(new TupleFieldModel(prop, field.Type)
						{
							DataType = typeMapping?.dataType
						});
					}
					break;
				}
				case ResultKind.Void:

					funcModel.Return = WellKnownTypes.System.ObjectNullable;
					break;
			}

			if (isNonDefaultSchema && _contextSettings.GenerateSchemaAsType)
				GetOrAddSchemaType(model, func.Name.Schema!).ScalarFunctions.Add(funcModel);
			else
				model.DataContext.ScalarFunctions.Add(funcModel);
		}

		private void BuildTableFunction(DatabaseModel model, TableFunction func, ISet<string> defaultSchemas)
		{
			var (name, isNonDefaultSchema) = ProcessObjectName(func.Name, defaultSchemas);

			var method = new MethodModel(_namingServices.NormalizeIdentifier(_contextSettings.ProcedureNameNormalization, name.Name))
			{
				Public = true,
				Summary = func.Description
			};

			var metadata = new TableFunctionMetadata(name);

			var funcModel = new TableFunctionModel(name, method, metadata, _namingServices.NormalizeIdentifier(_contextSettings.ProcedureMethodInfoFieldNameNormalization, func.Name.Name))
			{
				Error = func.SchemaError?.Message
			};

			BuildParameters(func.Parameters, funcModel.Parameters);

			if (func.Result != null)
				funcModel.Result = PrepareResultSetModel(func.Name, func.Result);

			if (isNonDefaultSchema && _contextSettings.GenerateSchemaAsType)
				GetOrAddSchemaType(model, func.Name.Schema!).TableFunctions.Add(funcModel);
			else
				model.DataContext.TableFunctions.Add(funcModel);
		}

		private void BuildStoredProcedure(DatabaseModel model, StoredProcedure func, ISet<string> defaultSchemas)
		{
			var (name, isNonDefaultSchema) = ProcessObjectName(func.Name, defaultSchemas);

			var method = new MethodModel(_namingServices.NormalizeIdentifier(_contextSettings.ProcedureNameNormalization, name.Name))
			{
				Public = true,
				Static = true,
				Summary = func.Description,
				Extension = true
			};

			var funcModel = new StoredProcedureModel(name, method)
			{
				Error = func.SchemaError?.Message
			};

			BuildParameters(func.Parameters, funcModel.Parameters);

			switch (func.Result.Kind)
			{
				case ResultKind.Void:
					break;
				case ResultKind.Dynamic:
					throw new NotImplementedException();
				case ResultKind.Tuple:
					throw new NotImplementedException();
				case ResultKind.Scalar:
				{
					var scalarResult = (ScalarResult)func.Result;
					var typeMapping = _typeMappingsProvider.GetTypeMapping(scalarResult.Type);

					var paramName = _namingServices.NormalizeIdentifier(_contextSettings.ProcedureParameterNameNormalization, scalarResult.Name ?? "return");
					funcModel.Return = new ReturnParameter(new ParameterModel(paramName, (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(scalarResult.Nullable), ParameterDirection.Out), scalarResult.Type)
					{
						DataType = typeMapping?.dataType,
						Name = scalarResult.Name,
						IsNullable = scalarResult.Nullable
					};
					break;
				}
			}

			if (func.ResultSets?.Count > 1)
			{
				//spm.ResultSetClassName = NormalizeIdentifier(
				//	settings.ProcedureResultSetClassNameNormalization,
				//	sp.Name.Name!,
				//	langServices,
				//	pluralizationProvider);
				//var idx = 1;
				//foreach (var rs in sp.ResultSets)
				//{
				//	spm.Results.Add(PrepareResultSetModel(dataModel, sp.Name, rs, settings, langServices, pluralizationProvider, idx, entities));
				//	idx++;
				//}
				// TODO: to support multi-result sets we need at least one implementation in schema provider
				throw new NotImplementedException();
			}
			else if (func.ResultSets?.Count == 1)
			{
				funcModel.Results.Add(PrepareResultSetModel(func.Name, func.ResultSets[0]));
			}

			if (isNonDefaultSchema && _contextSettings.GenerateSchemaAsType)
				GetOrAddSchemaType(model, func.Name.Schema!).StoredProcedures.Add(funcModel);
			else
				model.DataContext.StoredProcedures.Add(funcModel);
		}

		private (ObjectName name, bool isNonDefaultSchema) ProcessObjectName(ObjectName originalName, ISet<string> defaultSchemas)
		{
			var isNonDefaultSchema = originalName.Schema != null && !defaultSchemas.Contains(originalName.Schema);
			var name = originalName;
			if (!_contextSettings.GenerateDefaultSchema && !isNonDefaultSchema && originalName.Schema != null)
				name = name with { Schema = null };
			if (!_schemaSettings.IncludeDatabaseName)
				name = name with { Database = null };

			return (name, isNonDefaultSchema);
		}

		private void BuildParameters(IReadOnlyCollection<Parameter> parameters, List<FunctionParameterModel> models)
		{
			foreach (var param in parameters)
			{
				var typeMapping = _typeMappingsProvider.GetTypeMapping(param.Type);
				var paramName = _namingServices.NormalizeIdentifier(_contextSettings.ProcedureParameterNameNormalization, param.Name);

				ParameterDirection direction;
				switch (param.Direction)
				{
					case Schema.ParameterDirection.Input: direction = ParameterDirection.In; break;
					case Schema.ParameterDirection.InputOutput: direction = ParameterDirection.Ref; break;
					case Schema.ParameterDirection.Output: direction = ParameterDirection.Out; break;
					default:
						throw new InvalidOperationException();
				}

				var parameterModel = new ParameterModel(paramName, (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(param.Nullable), direction)
				{
					Description = param.Description
				};

				var fp = new FunctionParameterModel(parameterModel)
				{
					DbName = param.Name,
					Type = param.Type,
					DataType = typeMapping?.dataType,
					IsNullable = param.Nullable
				};

				models.Add(fp);
			}
		}

		private (ResultTableModel? customModel, EntityModel? entity) PrepareResultSetModel(
			ObjectName funcName,
			IReadOnlyCollection<ResultColumn> columns)
		{
			// try to find entity model with same set of columns by name, type and nullability to re-use as result model
			if (_contextSettings.MapProcedureResultToEntity)
			{
				var names = new Dictionary<string, (DatabaseType type, bool isNullable)>();
				foreach (var column in columns)
				{
					if (string.IsNullOrEmpty(column.Name) || names.ContainsKey(column.Name!))
						break;

					names.Add(column.Name!, (column.Type, column.Nullable));
				}

				if (names.Count == columns.Count)
				{
					foreach (var (schemaObject, entity) in _entities.Values)
					{
						if (schemaObject.Columns.Count == names.Count)
						{
							var match = true;
							foreach (var column in schemaObject.Columns)
							{
								if (!names.TryGetValue(column.Name, out var columnType)
									|| !column.Type.Equals(columnType.type)
									|| column.Nullable != columnType.isNullable)
								{
									match = false;
									break;
								}
							}

							if (match)
								return (null, _entities[schemaObject.Name].entity);
						}
					}
				}
			}

			var resultClass = new ClassModel(_namingServices.NormalizeIdentifier(_contextSettings.ProcedureResultClassNameNormalization, funcName.Name))
			{
				IsPublic = true,
				IsPartial = true
			};
			var model = new ResultTableModel(resultClass);

			foreach (var col in columns)
			{
				var typeMapping = _typeMappingsProvider.GetTypeMapping(col.Type);

				var metadata = new ColumnMetadata(col.Name ?? string.Empty)
				{
					DbType = col.Type,
					DataType = typeMapping?.dataType,
					CanBeNull =col.Nullable,
					SkipOnInsert = true,
					SkipOnUpdate = true
				};
				var property  = new PropertyModel(
					_namingServices.NormalizeIdentifier(_contextSettings.ProcedureResultColumnPropertyNameNormalization, col.Name ?? "Column"),
					(typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(col.Nullable))
				{
					IsPublic = true,
					HasSetter = true,
					IsDefault = true,
				};
				var colModel = new ColumnModel(metadata, property);
				model.Columns.Add(colModel);
			}

			return (model, null);
		}

		private AssociationModel? BuildAssociations(ForeignKey fk, ISet<string> defaultSchemas)
		{
			if (!_entities.TryGetValue(fk.Source, out var source)
				|| !_entities.TryGetValue(fk.Target, out var target))
				return null;

			var fromColumns = new ColumnModel[fk.Relation.Count];
			var toColumns = new ColumnModel[fk.Relation.Count];

			var fromOptional = true;
			// TODO: for now we only check that all columns are part of PK, but also should check for unique constraint in future
			var sourceIsUnique = true;
			for (var i = 0; i < fk.Relation.Count; i++)
			{
				var (srcColumn, targetColumn) = fk.Relation[i];
				fromColumns[i] = _columns[(source.entity, srcColumn)];
				toColumns[i] = _columns[(target.entity, targetColumn)];

				if (!fromColumns[i].Metadata.CanBeNull)
					fromOptional = false;
				if (!fromColumns[i].Metadata.IsPrimaryKey)
					sourceIsUnique = false;
			}

			var sourceMetadata = new AssociationMetadata(false, fromOptional);
			var targetMetadata = new AssociationMetadata(true, sourceIsUnique);

			var association = new AssociationModel(sourceMetadata, targetMetadata, source.entity, target.entity, !sourceIsUnique);

			association.FromColumns = fromColumns;
			association.ToColumns = toColumns;

			var summary = fk.Name;
			var backreferenceSummary = $"{fk.Name} backreference";

			var sourceColumnName = fk.Relation.Count == 1 ? fk.Relation[0].SourceColumn : null;

			var fromAssociationName = GenerateAssociationName(fk.Target, fk.Source, sourceColumnName, fk.Name, _contextSettings.SingularForeignKeyAssociationPropertyNameNormalization, defaultSchemas);
			string toAssocationName;
			if (!sourceIsUnique)
				toAssocationName = GenerateAssociationName(fk.Source, fk.Target, null, fk.Name, _contextSettings.MultiplePrimaryKeyAssociationPropertyNameNormalization, defaultSchemas);
			else
				toAssocationName = GenerateAssociationName(fk.Source, fk.Target, null, fk.Name, _contextSettings.SingularPrimaryKeyAssociationPropertyNameNormalization, defaultSchemas);

			if (_codegenSettings.GenerateAssociations)
			{
				association.Property = new PropertyModel(fromAssociationName)
				{
					IsPublic = true,
					IsDefault = true,
					HasSetter = true,
					Summary = summary
				};
				association.BackreferenceProperty = new PropertyModel(toAssocationName)
				{
					IsPublic = true,
					IsDefault = true,
					HasSetter = true,
					Summary = backreferenceSummary
				};
			}

			if (_codegenSettings.GenerateAssociationExtensions)
			{
				association.Extension = new MethodModel(fromAssociationName)
				{
					Public = true,
					Static = true,
					Extension = true,
					Summary = summary
				};

				association.BackreferenceExtension = new MethodModel(toAssocationName)
				{
					Public = true,
					Static = true,
					Extension = true,
					Summary = backreferenceSummary
				};
			}

			return association;
		}

		private string GenerateAssociationName(
			ObjectName thisTable,
			ObjectName otherTable,
			string? firstFromColumnName,
			string fkName,
			ObjectNormalizationSettings settings,
			ISet<string> defaultSchemas)
		{
			var name = otherTable.Name;
			if (settings.Transformation == NameTransformation.T4Association)
			{
				// port of SetForeignKeyMemberName method (approximate)

				string? newName = null;

				// TODO: interceptors
				//if (schemaOptions.GetAssociationMemberName != null)
				//{
				//	newName = schemaOptions.GetAssociationMemberName(key);

				//	if (newName != null)
				//		name = ToValidName(newName);
				//}

				//if (newName == null)
				{
					newName = fkName;

					if (firstFromColumnName != null && firstFromColumnName.ToLower().EndsWith("id"))
					{
						newName = firstFromColumnName;
						newName = newName.Substring(0, newName.Length - "id".Length).TrimEnd('_');
					}
					else
					{
						if (newName.StartsWith("FK_"))
							newName = newName.Substring(3);
						//if (newName.EndsWith("_BackReference"))
						//newName = newName.Substring(0, newName.Length - "_BackReference".Length);

						var tableName = otherTable;

						newName = string.Concat(newName
							.Split('_')
							.Where(_ =>
								_.Length > 0 && _ != tableName.Name &&
								(tableName.Schema == null || defaultSchemas.Contains(tableName.Schema) || _ != tableName.Schema)));

						var skip = true;
						newName = string.Concat(newName.EnumerateCharacters().Reverse().Select(_ =>
						{
							if (skip)
							{
								if (_.category == UnicodeCategory.DecimalDigitNumber)
									return string.Empty;
								else
									skip = false;
							}

							return _.character;
						}).Reverse());
					}

					if (string.IsNullOrEmpty(newName))
						newName = thisTable == otherTable ? thisTable.Name : fkName;
				}

				name = newName;
			}
			return _namingServices.NormalizeIdentifier(settings, name);
		}

		private DataContextModel BuildDataContext()
		{
			var className = _namingServices.NormalizeIdentifier(
				_contextSettings.DataContextClassNameNormalization,
				_contextSettings.ContextClassName ?? _schemaProvider.DatabaseName ?? "MyDataContext");

			var dataContextClass = new ClassModel(className, className)
			{
				IsPartial = true,
				IsPublic = true,
				Namespace = _codegenSettings.Namespace
			};

			if (_codegenSettings.BaseContextClass != null)
				dataContextClass.BaseType = _languageProvider.TypeParser.Parse(_codegenSettings.BaseContextClass, false);
			else
				dataContextClass.BaseType = WellKnownTypes.LinqToDB.Data.DataConnection;

			if (_codegenSettings.IncludeDatabaseInfo)
			{
				var summary = new StringBuilder();
				if (_schemaProvider.DatabaseName != null)
					summary.AppendFormat("Database       : {0}", _schemaProvider.DatabaseName).AppendLine();
				if (_schemaProvider.DataSource != null)
					summary.AppendFormat("Data Source    : {0}", _schemaProvider.DataSource).AppendLine();
				if (_schemaProvider.ServerVersion != null)
					summary.AppendFormat("Server Version : {0}", _schemaProvider.ServerVersion).AppendLine();

				if (summary.Length > 0)
					dataContextClass.Summary = summary.ToString();
			}

			var dataContext = new DataContextModel(dataContextClass);
			dataContext.HasDefaultConstructor = _contextSettings.HasDefaultConstructor;
			dataContext.HasConfigurationConstructor = _contextSettings.HasConfigurationConstructor;
			dataContext.HasUntypedOptionsConstructor = _contextSettings.HasUntypedOptionsConstructor;
			dataContext.HasTypedOptionsConstructor = _contextSettings.HasTypedOptionsConstructor;
			return dataContext;
		}

		private void BuildEntity(
			DatabaseModel model,
			TableLikeObject table,
			PrimaryKey? primaryKey,
			Identity? identity,
			ISet<string> defaultSchemas,
			IType? baseType)
		{
			var (tableName, isNonDefaultSchema) = ProcessObjectName(table.Name, defaultSchemas);

			var metadata = new EntityMetadata(tableName, table is View);

			var contextPropertyName = _contextSettings.EntityContextPropertyNameProvider?.Invoke(table);
			contextPropertyName = contextPropertyName != null
				? contextPropertyName
				: _namingServices.NormalizeIdentifier(
					_contextSettings.EntityContextPropertyNameNormalization,
					table.Name.Name);

			var className = _contextSettings.EntityClassNameProvider?.Invoke(table);
			var hasCustomClassName = className != null;

			className = className != null
				? className
				: _namingServices.NormalizeIdentifier(
					_contextSettings.EntityClassNameNormalization,
					table.Name.Name);

			// add schema name for all-in-one multi-schema model to class name
			// TODO: why not to add it to property too?
			if (!hasCustomClassName && !_contextSettings.GenerateSchemaAsType && isNonDefaultSchema)
				className = table.Name.Schema + "_" + className;

			var classModel = new ClassModel(className, _codegenSettings.ClassPerFile ? className : model.DataContext.Class.FileName!);
			classModel.Summary = table.Description;
			classModel.BaseType = baseType;
			classModel.IsPublic = true;
			classModel.Namespace = _codegenSettings.Namespace;

			var entity = new EntityModel(metadata, classModel, contextPropertyName == null
				? null
				// type is open-generic
				// type argument will be set later during ast generation
				: new PropertyModel(contextPropertyName, WellKnownTypes.LinqToDB.ITableT)
				{
					IsPublic = true,
					Summary = table.Description
				});
			model.OrderFindParametersByOrdinal = _codegenSettings.OrderFindParametersByColumnOrdinal;
			entity.HasFindExtension = _codegenSettings.GenerateFindExtensions;

			_entities.Add(table.Name, (table, entity));

			foreach (var column in table.Columns)
			{
				var typeMapping = _typeMappingsProvider.GetTypeMapping(column.Type);

				var columnMetadata = new ColumnMetadata(column.Name);

				var propertyName = _namingServices.NormalizeIdentifier(
					_contextSettings.EntityColumnPropertyNameNormalization,
					column.Name);

				var propertyType = (typeMapping?.clrType ?? WellKnownTypes.System.Object).WithNullability(column.Nullable);

				var columnProperty = new PropertyModel(propertyName, propertyType)
				{
					IsPublic = true,
					IsDefault = true,
					HasSetter = true,
					Summary = column.Description,
					TrailingComment = column.Type.Name
				};

				var columnModel = new ColumnModel(columnMetadata, columnProperty);
				entity.Columns.Add(columnModel);
				_columns.Add((entity, column.Name), columnModel);

				columnMetadata.DbType = column.Type;
				if (!_codegenSettings.GenerateDbType)
					columnMetadata.DbType = columnMetadata.DbType with { Name = null };
				if (!_codegenSettings.GenerateLength)
					columnMetadata.DbType = columnMetadata.DbType with { Length = null };
				if (!_codegenSettings.GeneratePrecision)
					columnMetadata.DbType = columnMetadata.DbType with { Precision = null };
				if (!_codegenSettings.GenerateScale)
					columnMetadata.DbType = columnMetadata.DbType with { Scale = null };

				if (_codegenSettings.GenerateDataType)
					columnMetadata.DataType = typeMapping?.dataType;

				columnMetadata.CanBeNull = column.Nullable;
				columnMetadata.SkipOnInsert = !column.Insertable;
				columnMetadata.SkipOnUpdate = !column.Updatable;
				columnMetadata.IsIdentity = identity != null && identity.Column == column.Name;

				if (primaryKey != null)
				{
					columnMetadata.IsPrimaryKey = primaryKey.Columns.Contains(column.Name);
					if (columnMetadata.IsPrimaryKey && primaryKey.Columns.Count > 1)
					{
						columnMetadata.PrimaryKeyOrder = primaryKey.GetColumnPositionInKey(column);
					}
				}
			}

			// add entity to model
			if (isNonDefaultSchema && _contextSettings.GenerateSchemaAsType)
				GetOrAddSchemaType(model, table.Name.Schema!).Entities.Add(entity);
			else
				model.DataContext.Entities.Add(entity);
		}

		private AdditionalSchemaModel GetOrAddSchemaType(DatabaseModel model, string schemaName)
		{
			if (!model.DataContext.AdditionalSchemas.TryGetValue(schemaName, out var schemaModel))
			{
				if (!_contextSettings.SchemaMap.TryGetValue(schemaName, out var baseName))
					baseName = schemaName;

				var schemaClassName = _namingServices.NormalizeIdentifier(
									_codegenSettings.SchemaClassNameNormalization,
									baseName);
				var contextPropertyName = _namingServices.NormalizeIdentifier(
									_codegenSettings.SchemaPropertyNormalization,
									baseName);

				var wrapperClass = new ClassModel(schemaClassName, _codegenSettings.ClassPerFile ? schemaClassName : model.DataContext.Class.FileName!)
				{
					IsPublic = true,
					IsPartial = true,
					IsStatic = true,
					Namespace = _codegenSettings.Namespace
				};
				var contextClass = new ClassModel("DataContext")
				{
					IsPublic = true,
					IsPartial = true
				};
				schemaModel = new AdditionalSchemaModel(contextPropertyName, wrapperClass, contextClass);
				model.DataContext.AdditionalSchemas.Add(schemaName, schemaModel);
			}

			return schemaModel;
		}

		//			if (!proc.IsFunction && getProcedures)
		//			{
		//				if (returnValue == null && settings.AddReturnParameterToProcedures.Contains(name))
		//				{
		//					// TODO: execute only for sql server
		//					// this is sqlserver-specific option
		//					var dbType = new DatabaseType(false, "int", null, null, null, DataType.Int32);
		//					returnValue = new ReturnValue("@return", dbType);
		//					if (!model.TypeMap.ContainsKey(dbType))
		//					{
		//						model.TypeMap.Add(dbType, (DataType.Int32, typeof(int), "SqlInt32"));
		//					}
		//				}

		//				var sproc = new StoredProcedure(name, procDescription, parameters, proc.ResultException, results, returnValue);
		//				model.StoredProcedures.Add(sproc);
		//			}
	}
}
