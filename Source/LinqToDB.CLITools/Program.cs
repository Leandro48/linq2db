using System.Data.Common;
using System.IO;
using System.Reflection;
using LinqToDB.CodeGen.CodeGeneration;
using LinqToDB.CodeGen.Configuration;
using LinqToDB.CodeGen.ContextModel;
using LinqToDB.CodeGen.DataModel;
using LinqToDB.CodeGen.Metadata;
using LinqToDB.CodeGen.Model;
using LinqToDB.Data;
using Microsoft.Extensions.Configuration;

namespace LinqToDB.Tools
{
	internal static class Program
	{
		private static int Main(string[] args)
		{
			Directory.CreateDirectory(@"..\..\..\Generated");

			//BuildModel("access.oledb");
			BuildModel("sql.2017");
			//BuildModel("db2");
			//BuildModel("pg10");

			if (args.Length == 0) return 0;

			NameNormalizationTest.NormalizationTest();

			BuildModel("sqlite.classic");
			BuildModel("sqlite.ms");
			BuildModel("sqlite.nw.classic");
			BuildModel("sqlite.nw.ms");
			//var sqlce = Assembly.LoadFrom(@"c:\Program Files\Microsoft SQL Server Compact Edition\v4.0\Desktop\System.Data.SqlServerCe.dll");
			//BuildModel("sqlce");
			BuildModel("firebird25");
			BuildModel("firebird3");
			BuildModel("firebird4");
			BuildModel("sql.2005");
			BuildModel("sql.2008");
			BuildModel("sql.2012");
			BuildModel("sql.2014");
			BuildModel("sql.2017");
			BuildModel("sql.contained");
			BuildModel("sql.2019");
			BuildModel("sql.2019.ms");
			BuildModel("sql.nw");
			BuildModel("sql.azure");
			BuildModel("mysql");
			BuildModel("mysql55");
			BuildModel("mysqlconnector");
			BuildModel("mariadb");
			BuildModel("pg92");
			BuildModel("pg93");
			BuildModel("pg95");
			BuildModel("pg10");
			BuildModel("pg11");
			BuildModel("access.oledb");
			BuildModel("access.odbc");
			BuildModel("sybase.managed");
			BuildModel("db2");
			BuildModel("db2.ifx");
			BuildModel("ora11.managed");
			BuildModel("sap.odbc");

			RegisterSapHanaFactory();
			BuildModel("sap.native");

			//BuildModel("sqlite");
			//BuildModel("sql2017");
			//BuildModel("pg11");

			return 0;
		}

		private static void RegisterSapHanaFactory()
		{
			try
			{
				// woo-hoo, hardcoded pathes! default install location on x64 system
				var srcPath = @"c:\Program Files (x86)\sap\hdbclient\dotnetcore\v2.1\Sap.Data.Hana.Core.v2.1.dll";
				var targetPath = Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory!, Path.GetFileName(srcPath));
				if (File.Exists(srcPath))
				{
					// original path contains spaces which breaks broken native dlls discovery logic in SAP provider
					// if you run tests from path with spaces - it will not help you
					File.Copy(srcPath, targetPath, true);
					var sapHanaAssembly = Assembly.LoadFrom(targetPath);
					DbProviderFactories.RegisterFactory("Sap.Data.Hana", sapHanaAssembly.GetType("Sap.Data.Hana.HanaFactory")!);
				}
			}
			catch { }
		}

		private static void BuildModel(string configName)
		{
			var config = new ConfigurationBuilder()
				.AddJsonFile($"Configuration\\{configName}.json", true, false)
				.Build();

			IModelSettings settings =  new ModelSettings(config);

			var schemaSettings = new SchemaSettings();
			var contextSettings = new ContextModelSettings();
			var codegenSettings = new CodeGenerationSettings();

			codegenSettings.MarkAsAutoGenerated = true;
			contextSettings.GenerateSchemaAsType = true;
			codegenSettings.BaseContextClass = "LinqToDB.DataContext";
			codegenSettings.Namespace = $"DataModel.{configName}";
			codegenSettings.ClassPerFile = true;

			// namespace generated by naming test
			codegenSettings.ConflictingNames.Add("DataType");

			var languageProvider = LanguageProviders.CSharp;

			var nameConverter = new HumanizerNameConverter();

			using (var dc = new DataConnection(settings.Provider, settings.ConnectionString))
			{
				var schemaProvider = new CodeGen.Schema.SchemaProvider(dc, schemaSettings, languageProvider);
				var namingServices = new NamingServices(languageProvider, nameConverter);

				var modelBuilder = new ModelBuilder(schemaProvider, schemaProvider, languageProvider, schemaSettings, codegenSettings, contextSettings, nameConverter, namingServices);
				var dataModel = modelBuilder.Build();

				var sqlBuilder = dc.DataProvider.CreateSqlBuilder(dc.MappingSchema);
				var builder = new CodeBuilder(languageProvider);
				var metadata = new AttributeBasedMetadataBuilder(builder, sqlBuilder);

				var generator = new DataModelGenerator(languageProvider, dataModel, metadata, namingServices, codegenSettings.ParameterNameNormalization, sqlBuilder);
				var files = generator.ConvertToCodeModel();

				var equalityConverter = SqlBoolEqualityConverter.Create(languageProvider);
				for (var i = 0; i < files.Length; i++)
					files[i] = (CodeFile)equalityConverter.Visit(files[i]);

				var codeBuilder = new CodeModelBuilder(codegenSettings, nameConverter, languageProvider, metadata, builder, namingServices, sqlBuilder);
				var source = codeBuilder.GetSourceCode(files);

				var root = $@"..\..\..\Generated\{configName}";
				Directory.CreateDirectory(root);

				for (var i = 0; i < files.Length; i++)
				{
					// TODO: file name normalization/deduplication
					File.WriteAllText($@"{root}\{files[i].FileName}.{languageProvider.FileExtension}", source[i]);
				}
			}

			//ISqlBuilder sqlBuilder;
			
			//{
			//	model = ModelBuilder.LoadServerMetadata(dc, schemaSettings);
			//	sqlBuilder = dc.DataProvider.CreateSqlBuilder(dc.MappingSchema);
			//}

			//var dataContext = ContextModelBuilder.Build(sqlBuilder, model, contextSettings, new CSharpLanguageServices(), contextSettings.NameConverter);

			//var sourceCode = ModelGenerator.GenerateContextModel(dataContext, codegenSettings, contextSettings.NameConverter);


			//File.WriteAllText($@"..\..\..\Generated\{configName}.cs", sourceCode);

			//return sourceCode;
		}

		//private static string TestPG11()
		//{
		//	var config = new ConfigurationBuilder()
		//		.AddJsonFile("pg11.json", true, false)
		//		.Build();

		//	IModelSettings settings =  new ModelSettings(config);
		//	var schemaSettings = new SchemaSettings();
		//	schemaSettings.Objects = SchemaObjects.Table | SchemaObjects.View | SchemaObjects.ForeignKey
		//		| SchemaObjects.ScalarFunction | SchemaObjects.TableFunction | SchemaObjects.Aggregate | SchemaObjects.StoredProcedure;
		//	schemaSettings.LoadProcedureSchema = p => true;
		//	schemaSettings.PreferProviderSpecificTypes = false;
		//	var contextSettings = new ContextModelSettings();
		//	contextSettings.NameConverter = new HumanizerNameConverter();


		//	contextSettings.GenerateDefaultSchema = true;
		//	contextSettings.EntityContextPropertyNameProvider = contextSettings.EntityClassNameProvider = t => t.Name.Schema == "public" && t.Name.Name == "testsamename" ? "_testsamename" : null;

		//	DataModel model;
		//	ISqlBuilder sqlBuilder;
		//	using (var dc = new DataConnection(settings.Provider, settings.ConnectionString))
		//	{
		//		model = ModelBuilder.LoadServerMetadata(dc, schemaSettings);
		//		sqlBuilder = dc.DataProvider.CreateSqlBuilder(dc.MappingSchema);
		//	}

		//	var dataContext = ContextModelBuilder.Build(sqlBuilder, model, contextSettings, new CSharpLanguageServices(), contextSettings.NameConverter);

		//	var codegenSettings = new CodeGenerationSettings();
		//	codegenSettings.MarkAsAutoGenerated = true;
		//	codegenSettings.NullableReferenceTypes = true;
		//	codegenSettings.Namespace = "PostreSQL11DataContext";
		//	codegenSettings.IncludeDatabaseInfo = false;
		//	codegenSettings.GenerateDbType = false;
		//	codegenSettings.GenerateDataType = true;
		//	codegenSettings.GenerateLength = true;
		//	codegenSettings.GeneratePrecision = true;
		//	codegenSettings.GenerateScale = true;
		//	codegenSettings.GenerateAssociationExtensions = false;
		//	codegenSettings.ConflictingNamespaces.Add("DataType"); // from tests
		//	var sourceCode = ModelGenerator.GenerateContextModel(dataContext, codegenSettings, contextSettings.NameConverter);


		//	File.WriteAllText(@"..\..\..\Generated\pg11.cs", sourceCode);

		//	return sourceCode;
		//}

		//private static string TestSQLite()
		//{
		//	var config = new ConfigurationBuilder()
		//		.AddJsonFile("sqlite.json", true, false)
		//		.Build();

		//	SqlServerTools.ResolveSqlTypes(typeof(SqlGeography).Assembly);

		//	IModelSettings settings =  new ModelSettings(config);
		//	var schemaSettings = new SchemaSettings();
		//	schemaSettings.Objects = SchemaObjects.Table | SchemaObjects.View | SchemaObjects.ForeignKey
		//		| SchemaObjects.ScalarFunction | SchemaObjects.TableFunction | SchemaObjects.Aggregate | SchemaObjects.StoredProcedure;
		//	schemaSettings.LoadProcedureSchema = p => true;
		//	var contextSettings = new ContextModelSettings();
		//	contextSettings.NameConverter = new HumanizerNameConverter();
		//	contextSettings.GenerateSchemaAsType = true;

		//	DataModel model;
		//	ISqlBuilder sqlBuilder;
		//	using (var dc = new DataConnection(settings.Provider, settings.ConnectionString))
		//	{
		//		model = ModelBuilder.LoadServerMetadata(dc, schemaSettings);
		//		sqlBuilder = dc.DataProvider.CreateSqlBuilder(dc.MappingSchema);
		//	}

		//	var dataContext = ContextModelBuilder.Build(sqlBuilder, model, contextSettings, new CSharpLanguageServices(), contextSettings.NameConverter);

		//	var codegenSettings = new CodeGenerationSettings();
		//	codegenSettings.MarkAsAutoGenerated = true;
		//	codegenSettings.NullableReferenceTypes = true;
		//	codegenSettings.Namespace = "SQLiteDataContext";
		//	codegenSettings.IncludeDatabaseInfo = false;
		//	codegenSettings.GenerateDbType = false;
		//	codegenSettings.GenerateDataType = false;
		//	codegenSettings.GenerateLength = false;
		//	codegenSettings.GeneratePrecision = false;
		//	codegenSettings.GenerateScale = false;
		//	var sourceCode = ModelGenerator.GenerateContextModel(dataContext, codegenSettings, contextSettings.NameConverter);


		//	File.WriteAllText(@"..\..\..\Generated\sqlite.cs", sourceCode);

		//	return sourceCode;
		//}

		//private static string TestSQL2017()
		//{
		//	var config = new ConfigurationBuilder()
		//		.AddJsonFile("sql2017.json", true, false)
		//		.Build();

		//	SqlServerTools.ResolveSqlTypes(typeof(SqlGeography).Assembly);

		//	IModelSettings settings =  new ModelSettings(config);
		//	var schemaSettings = new SchemaSettings();
		//	schemaSettings.Objects = SchemaObjects.Table | SchemaObjects.View | SchemaObjects.ForeignKey
		//		| SchemaObjects.ScalarFunction | SchemaObjects.TableFunction | SchemaObjects.Aggregate | SchemaObjects.StoredProcedure;
		//	schemaSettings.LoadTable = t => t.Name != "Person";// && t.Name != "Products";
		//	schemaSettings.LoadProcedureSchema = p => true;
		//	schemaSettings.AddReturnParameterToProcedures.Add(new ObjectName(null, null, "dbo", "Issue1897"));
		//	var contextSettings = new ContextModelSettings();
		//	contextSettings.NameConverter = new HumanizerNameConverter();
		//	contextSettings.GenerateSchemaAsType = true; // sqlserver2017
		//	contextSettings.SchemaMap.Add("TestSchema", "MySchema");

		//	DataModel model;
		//	ISqlBuilder sqlBuilder;
		//	using (var dc = new DataConnection(settings.Provider, settings.ConnectionString))
		//	{
		//		model = ModelBuilder.LoadServerMetadata(dc, schemaSettings);
		//		sqlBuilder = dc.DataProvider.CreateSqlBuilder(dc.MappingSchema);
		//	}

		//	var dataContext = ContextModelBuilder.Build(sqlBuilder, model, contextSettings, new CSharpLanguageServices(), contextSettings.NameConverter);

		//	var codegenSettings = new CodeGenerationSettings();
		//	codegenSettings.MarkAsAutoGenerated = true;
		//	codegenSettings.NullableReferenceTypes = true;
		//	codegenSettings.Namespace = "Sql2017ProcSchema";
		//	codegenSettings.IncludeDatabaseInfo = false;
		//	codegenSettings.GenerateDbType = true;
		//	codegenSettings.GenerateDataType = true;
		//	codegenSettings.GenerateLength = true;
		//	codegenSettings.GeneratePrecision = true;
		//	codegenSettings.GenerateScale = true;
		//	codegenSettings.AssociationCollectionType = "System.Collections.Generic.List<>";
		//	var sourceCode = ModelGenerator.GenerateContextModel(dataContext, codegenSettings, contextSettings.NameConverter);


		//	File.WriteAllText(@"..\..\..\Generated\sql2017.cs", sourceCode);

		//	return sourceCode;
		//}
	}
}

